"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const minimatch = require("minimatch");
const fspath = require("path");
const lsu = require("./ls-utils");
const subProcess = require("./sub-process");
class Docker {
    constructor(targetImage, options) {
        this.targetImage = targetImage;
        this.optionsList = Docker.createOptionsList(options);
    }
    static run(args, options) {
        return subProcess.execute("docker", [
            ...Docker.createOptionsList(options),
            ...args,
        ]);
    }
    static createOptionsList(options) {
        const opts = [];
        if (!options) {
            return opts;
        }
        if (options.host) {
            opts.push(`--host=${options.host}`);
        }
        if (options.tlscert) {
            opts.push(`--tlscert=${options.tlscert}`);
        }
        if (options.tlscacert) {
            opts.push(`--tlscacert=${options.tlscacert}`);
        }
        if (options.tlskey) {
            opts.push(`--tlskey=${options.tlskey}`);
        }
        if (options.tlsverify) {
            opts.push(`--tlsverify=${options.tlsverify}`);
        }
        return opts;
    }
    /**
     * Runs the command, catching any expected errors and returning them as normal
     * stderr/stdout result.
     */
    runSafe(cmd, args = []) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.run(cmd, args);
            }
            catch (error) {
                const stderr = error.stderr;
                if (typeof stderr === "string") {
                    if (stderr.indexOf("No such file") >= 0 ||
                        stderr.indexOf("file not found") >= 0) {
                        return { stdout: error.stdout, stderr };
                    }
                }
                throw error;
            }
        });
    }
    run(cmd, args = []) {
        return subProcess.execute("docker", [
            ...this.optionsList,
            "run",
            "--rm",
            "--entrypoint",
            '""',
            "--network",
            "none",
            this.targetImage,
            cmd,
            ...args,
        ]);
    }
    inspect(targetImage) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return subProcess.execute("docker", [
                ...this.optionsList,
                "inspect",
                targetImage,
            ]);
        });
    }
    catSafe(filename) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.runSafe("cat", [filename]);
        });
    }
    lsSafe(path, recursive) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let params = "-1ap";
            if (recursive) {
                params += "R";
            }
            return this.runSafe("ls", [params, path]);
        });
    }
    /**
     * Find files on a docker image according to a given list of glob expressions.
     */
    findGlobs(globs, exclusionGlobs = [], path = "/", recursive = true) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const res = [];
            const root = yield this.lsSafe(path, recursive).then((output) => lsu.parseLsOutput(output.stdout));
            lsu.iterateFiles(root, (f) => {
                const filepath = fspath.join(f.path, f.name);
                let exclude = false;
                exclusionGlobs.forEach((g) => {
                    if (!exclude && minimatch(filepath, g)) {
                        exclude = true;
                    }
                });
                if (!exclude) {
                    globs.forEach((g) => {
                        if (minimatch(filepath, g)) {
                            res.push(filepath);
                        }
                    });
                }
            });
            return res;
        });
    }
}
exports.Docker = Docker;
//# sourceMappingURL=docker.js.map